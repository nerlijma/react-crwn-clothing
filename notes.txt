> yarn add node-sass
> yarn start

Mode Sass version 6.0.1 is incompatible with ^4.0.0 || ^5.0.0.
1. yarn remove node-sass
2. Add "sass-loader": "^11.1.1" as web_Dependency in package.json
3. Delete node_modules and yarn.lock
4. yarn

import SectionsData from './directory.data.json'

En el constructor:
this.state = {
	sections: SectionsData
}

https://fonts.google.com/specimen/Open+Sans+Condensed?query=condensed
vas a index.html y agregas el

<link href="https://fonts.googleapis.com/css2?family=Open+Sans+Condensed:wght@300&display=swap" rel="stylesheet">

React Router

yarn add react-router-dom

Si hay conflictos, se puede agregar

"devDependencies": {
},

"resolutions": {
    "babel-jest": "24.7.1" (o similar)
}

props.match.params.topicId (leer parametros de la url)

Avoid property drilling... (pasar las prop a multiples hijos que no los usan)

import {withRouter} from 'react-router-dom'
export default withRouter(MenuItem);

Destructuring and spread
collections.map( ({id, ...otherProps}) => (
	<CollectionPreview key={id} {...otherProps} />
))

Usar una imagen como un elemento de react
import { ReactComponent as Logo } from '../../assets/crown.svg'
<Logo />

Cuando haces una funcion con => arreglas el this. Para que sea del contexto de la clase cuando haces 
this.setState

ALT + Click: Agregas un segundo cursor en VS code

*** Firebase
Crear el proyecto en https://console.firebase.google.com/
Ir a agregar a proyecto web (Proyect Overview / Web)
copiar el objeto con la configuracion de firebase
> yarn add firebase 

Para poner un atributo true, no es necesario hacer ={true} con <CustomButton isGoogleSignin es suficiente
<CustomButton isGoogleSignin onClick={signInWithGoogle}>Sign in with Google</CustomButton>

Cuando ponemos &. en sas equivale a .custom-button.google-sign-in 

class="custom-button google-sign-in"

.custom-button {
    &.google-sign-in {
        background-color: #4285f4;
    }
}

Cuando usamso @mixin en SAS es para reutilizra codigo

@mixin shrinkLabel {
  top: -14px;
  font-size: 12px;
  color: $main-color;
}

&.shrink {
	@include shrinkLabel();
}

FireStore
Production Mode (privada nadie puede escribir ni leer solo por reglas) vs Test Mode (cualquiera puede leer y escribir)
QueryReference - Objecto de la colleccion que represento. (auque no existe)
QuerySnapshot  -  Haciendo get() de la reference se obtienen los datos. Crud se hace con snapshot.

En v9
Hay que buscar una referencia doc o collection
const userRef = doc(db, `users/${userAuth.uid}`);

y luego guardarla con setDoc o setCollection
await setDoc(userRef, data);

Te subscribis a los cambios con onSnapshot

onSnapshot(userRef, doc => {
	this.setState({
	currentUser: {
		id: doc.id,
		...doc.data()
	}
});

Para usar await, la funcion debe estar declarada con async

    handleSubmit = async e => {
        e.preventDefault();
        await createUserProfileWithEmailAndPassword(this.state);
        this.setState({ email: '', password: '', displayName: '', confirmPassword: '' });
    }

https://ant.design/components/table/
http://flexboxfroggy.com/

Solo para el caso de google, si te logueas con usuario y password, y luego con google. 
Te pisa la autenticación de usuario y contraseña. No pasa al reves.
Si queres tener google y email y contraseña tenes que estar logueado y linkear con otro proveedor
https://firebase.google.com/docs/auth/web/account-linking

Redux
- Single source of truth
- One way dataflow
- State is red only (inmutability) Se crea siempre un nuevo estato
- Changes using pure functions
- Evita pasar props entre hijos que no se usan
- Hay un reducer para cada modulo

Action -> Reducer (pure function) -> Store updated -> DOM Changes

EN el reducer siempre se retorna un nuevo objeto

switch (action.type)  {
case 'SET_CURRENT_USER':
	return {
		...currentState,
		currentUser: action.payload
	}
default:
	return currentState;
}

Hay middelwares que ejecutan antes de llegar al reducer. Ej Logger

> yarn add redux redux-logger react-redux

reducer/root-reducer.js contiene todos los reducers de los modulos. user-reducer.jsx etc.

Se combinan en uno solo en el root-reduer.js

export default combineReducers({
    user: userReducer
});

** Leer estado Redux
Hay que mapear el state to props en cada componente

const mapStateToProps = state => ({
    currentUser: state.user.currentUser
})

export default connect(mapStateToProps)(Header);

** Dispatch Actions Redux
Para llamar a una action, hay que mepearla a una funcion disponible en props.

para luego llamarla: this.props.setCurrentUser o setCurrentUser() si haces  un destruct de this.props

const mapDispatchToProps = dispatch => ({
  setCurrentUser: user => dispatch(setCurrentUser(user))
})

export default connect(null, mapDispatchToProps)(App);

La forma mas similar a ngIf*:

{(visible) && <CartDropdown />}

Los function components siepre reciben props de parametro. Si haces destruct va siempre con {}
y puede ser atributo, objecto o funcion de Redux. Ej {item, setItem, etc}

Spread array [...array, {new Item}] - Agrega un item al array
Spread obj {...obj, prop}           - AGrega una prop al obj

Hacer destruct aniaddo
Si paso props, y adentro tiene item puedo hacer 
{item: {name, imageUrl, quantity}} 

Debugger: hay que buscar el lunch.json y cambiar la url para que sea la misma.